package com.imysak.thrift.commons;

import org.apache.commons.pool.PoolableObjectFactory;
import org.apache.thrift.TServiceClient;
import org.apache.thrift.protocol.TBinaryProtocol;
import org.apache.thrift.protocol.TProtocol;
import org.apache.thrift.transport.TSocket;
import org.apache.thrift.transport.TTransport;

/**
 * An apache-commons-pool factory for Thrift clients. It creates ClientWrapper objects
 * which, as the name says, wraps a connected Thrift client with some extra management
 * data.
 * 
 * @author cdegroot
 * 
 * @param <ClientType> the class of the generated thrift client.
 */
public class PoolableClientFactory<ClientType> implements PoolableObjectFactory {

    static class ClientWrapper<ClientType> {
        // TODO make this configurable
        public final static int MAX_INVOCATION_COUNT = 1000;
        public final static long MAX_AGE_IN_MS = 60 * 1000; // 1 minute in ms

        ClientType client;
        int invocationCount;
        final long creationTimestamp;

        ClientWrapper() {
            invocationCount = 0;
            creationTimestamp = currentTimestamp();
        }

        /**
         * Register that this wrapper's client was used in a call. This fact
         * is used to keep track of whether a client needs to be recycled.
         */
        public void registerSuccessfulCall() {
            invocationCount++;
        }

        boolean invokedEnough() {
            return invocationCount >= MAX_INVOCATION_COUNT;
        }

        boolean tooOld() {
            final long age = currentTimestamp() - creationTimestamp;
            return age >= MAX_AGE_IN_MS;
        }

        /**
         * Checks whether the client this object wraps needs to be recycled (iow,
         * junked and re-opened). We recycle regularly in order to give the load
         * balancers a chance to do their work.
         *
         * @return true if the client has done its share of work.
         */
        public boolean clientNeedsRecycling() {
            return invokedEnough() || tooOld();
        }

        long currentTimestamp() {
            return System.currentTimeMillis();
        }

    }

    private final Class<? extends ClientType> clientClass;
    private final String host;
    private final int port;

    /**
     * Constructs a PoolableClientFactory that connects the given client Thrift implementation
     * to the specified host and port.
     *
     * @param clientClass the client class generated by the Thrift compiler
     * @param host the host to connect to
     * @param port the port to connect to
     */
    public PoolableClientFactory(final Class<? extends ClientType> clientClass, final String host, final int port) {
        this.clientClass = clientClass;
        this.host = host;
        this.port = port;
    }

    /**
     *  If the client hasn't opened the socket yet, do it now. Note that
     *  input protocol = output protocol for our clients, they're identical.
     */
    @Override
    public void activateObject(final Object arg0) throws Exception {
        final ClientWrapper<ClientType> wrapper = getWrapperFromObjectArg(arg0);
        final TServiceClient client = (TServiceClient) wrapper.client;
        final TProtocol protocol = client.getInputProtocol();
        final TTransport transport = protocol.getTransport();
        if (!transport.isOpen()) {
            transport.open();
        }
    }

    /**
     * On destruction, the transport is closed. The rest is left to GC. Again,
     * input protocol = output protocol, so we only close once.
     */
    @Override
    public void destroyObject(final Object arg0) throws Exception {
        final ClientWrapper<ClientType> wrapper = getWrapperFromObjectArg(arg0);
        final TServiceClient client = (TServiceClient) wrapper.client;
        client.getInputProtocol().getTransport().close();
    }

    /**
     * The actual factory method. Creates an unconnected client wrapped in a
     * ClientWrapper object.
     */
    @Override
    public ClientWrapper<ClientType> makeObject() throws Exception {
        final TSocket tSocket = new TSocket(host, port);
        final TBinaryProtocol tBinaryProtocol = new TBinaryProtocol(tSocket);
        final ClientWrapper<ClientType> wrapper = new ClientWrapper<ClientType>();
        wrapper.client = clientClass.getConstructor(TProtocol.class).newInstance(tBinaryProtocol);
        return wrapper;
    }

    /**
     * A NOP for the time being.
     */
    @Override
    public void passivateObject(final Object arg0) throws Exception {
    }

    /**
     * During validation, we check whether the client needs to be recycled. If yes,
     * we return false so that the pool destroys the object.
     */
    @Override
    public boolean validateObject(final Object objectToVerify) {
        final ClientWrapper<ClientType> wrapper = getWrapperFromObjectArg(objectToVerify);

        // Check whether transport is open
        final TServiceClient client = (TServiceClient) wrapper.client;
        final TTransport transport = client.getInputProtocol().getTransport();
        if (!transport.isOpen()) {
            return false;
        }

        // Check whether wrapper thinks this client has aged
        if (wrapper.clientNeedsRecycling()) {
            return false;
        }

        // sorry, can't help it - this instance is actually valid :)
        return true;
    }

    /**
     * Wraps an ugly cast we use all over the place so we only need to suppress
     * unchecked type conversion warnings in one place.
     */
    @SuppressWarnings("unchecked")
    private ClientWrapper<ClientType> getWrapperFromObjectArg(final Object shouldBeClientWrapper) {
        return (ClientWrapper<ClientType>) shouldBeClientWrapper;
    }
}
